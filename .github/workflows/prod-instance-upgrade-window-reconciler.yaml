name: Reconcile Prod Instance Upgrade Window

on:
  workflow_dispatch:
  schedule:
    # GitHub's minimum cron interval is 5 minutes.
    - cron: "*/5 * * * *"

permissions:
  contents: write
  actions: write

concurrency:
  group: prod-instance-upgrade-window-reconciler
  cancel-in-progress: false

jobs:
  reconcile:
    name: Reconcile prod service plan and database routing window
    runs-on: ubuntu-latest
    steps:
      - name: Load configured upgrade window
        id: window
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ARTIFACT_NAME="prod-instance-upgrade-window"
          LIST_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?name=${ARTIFACT_NAME}&per_page=100"

          list_status=$(curl -sS -o /tmp/window_artifacts.json -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$LIST_URL")

          if [ "$list_status" != "200" ]; then
            echo "::error::Unable to list window artifacts (HTTP ${list_status})."
            cat /tmp/window_artifacts.json
            exit 1
          fi

          artifact_json="$(jq -c '[.artifacts[] | select(.expired == false)] | sort_by(.created_at) | last // empty' /tmp/window_artifacts.json)"
          if [ -z "$artifact_json" ]; then
            echo "::notice::No active upgrade window artifact found (${ARTIFACT_NAME})."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          artifact_id="$(echo "$artifact_json" | jq -r '.id // empty')"
          artifact_created_at="$(echo "$artifact_json" | jq -r '.created_at // empty')"
          archive_url="$(echo "$artifact_json" | jq -r '.archive_download_url // empty')"

          if [ -z "$artifact_id" ] || [ -z "$archive_url" ]; then
            echo "::error::Artifact metadata is incomplete."
            echo "$artifact_json"
            exit 1
          fi

          download_status=$(curl -sS -L -o /tmp/window_artifact.zip -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$archive_url")

          if [ "$download_status" -ge 300 ]; then
            echo "::error::Unable to download window artifact (HTTP ${download_status})."
            exit 1
          fi

          if ! unzip -p /tmp/window_artifact.zip instance-window.json > window.json 2>/dev/null; then
            echo "::error::Window artifact does not contain instance-window.json."
            exit 1
          fi

          if ! jq -e . window.json >/dev/null 2>&1; then
            echo "::error::Window payload is not valid JSON."
            cat window.json
            exit 1
          fi

          enabled="$(jq -r '.enabled // true' window.json)"
          if [ "$enabled" != "true" ]; then
            echo "::notice::Upgrade window is disabled."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          service_name="$(jq -r '.service_name // empty' window.json)"
          service_from_plan="$(jq -r '.service_from_plan // .from_plan // empty' window.json)"
          service_to_plan="$(jq -r '.service_to_plan // .to_plan // empty' window.json)"
          default_database_name="$(jq -r '.default_database_name // .database_name // "gfed-medusa-database"' window.json)"
          window_database_name="$(jq -r '.window_database_name // "gfed-medusa-database-paid"' window.json)"
          database_url_env_key="$(jq -r '.database_url_env_key // "DATABASE_URL"' window.json)"
          database_name_env_key="$(jq -r '.database_name_env_key // "DB_NAME"' window.json)"
          start_epoch="$(jq -r '.start_epoch // empty' window.json)"
          end_epoch="$(jq -r '.end_epoch // empty' window.json)"
          start_utc="$(jq -r '.start_utc // empty' window.json)"
          end_utc="$(jq -r '.end_utc // empty' window.json)"

          if [ -z "$service_name" ] || [ -z "$service_from_plan" ] || [ -z "$service_to_plan" ] || [ -z "$default_database_name" ] || [ -z "$window_database_name" ] || [ -z "$database_url_env_key" ] || [ -z "$database_name_env_key" ] || [ -z "$start_epoch" ] || [ -z "$end_epoch" ]; then
            echo "::error::Window payload is missing required fields."
            cat window.json
            exit 1
          fi

          case "$start_epoch" in
            (*[!0-9]*|'')
              echo "::error::start_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          case "$end_epoch" in
            (*[!0-9]*|'')
              echo "::error::end_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          now_epoch="$(date -u +%s)"
          now_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

          if [ "$now_epoch" -lt "$start_epoch" ]; then
            phase="before_start"
            target_service_plan="$service_from_plan"
            target_database_name="$default_database_name"
          elif [ "$now_epoch" -lt "$end_epoch" ]; then
            phase="inside_window"
            target_service_plan="$service_to_plan"
            target_database_name="$window_database_name"
          else
            phase="after_end"
            target_service_plan="$service_from_plan"
            target_database_name="$default_database_name"
          fi

          echo "::notice::Current phase: ${phase}; target service plan: ${target_service_plan}; target database routing: ${target_database_name}"
          {
            echo "configured=true"
            echo "artifact_id=$artifact_id"
            echo "artifact_created_at=$artifact_created_at"
            echo "service_name=$service_name"
            echo "default_database_name=$default_database_name"
            echo "window_database_name=$window_database_name"
            echo "database_url_env_key=$database_url_env_key"
            echo "database_name_env_key=$database_name_env_key"
            echo "target_service_plan=$target_service_plan"
            echo "target_database_name=$target_database_name"
            echo "phase=$phase"
            echo "service_from_plan=$service_from_plan"
            echo "service_to_plan=$service_to_plan"
            echo "start_utc=$start_utc"
            echo "end_utc=$end_utc"
            echo "now_utc=$now_utc"
          } >> "$GITHUB_OUTPUT"

      - name: Checkout default branch
        if: steps.window.outputs.configured == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch || github.ref_name }}
          fetch-depth: 0

      - name: Resolve Blueprint for target service
        if: steps.window.outputs.configured == 'true'
        id: blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          service_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/services?name=${SERVICE_NAME}&limit=1" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          service_body="$(echo "$service_resp" | head -n -1)"
          service_status="$(echo "$service_resp" | tail -n 1)"

          if [ "$service_status" -ge 300 ]; then
            echo "::error::Failed to fetch Render service '${SERVICE_NAME}' (HTTP ${service_status})."
            echo "$service_body"
            exit 1
          fi

          service_id="$(echo "$service_body" | jq -r '.[0].service.id // empty')"
          service_type="$(echo "$service_body" | jq -r '.[0].service.type // empty')"

          if [ -z "$service_id" ]; then
            echo "::error::Render service not found: ${SERVICE_NAME}"
            exit 1
          fi

          if [ "$service_type" != "web_service" ]; then
            echo "::error::Expected '${SERVICE_NAME}' to be a web service, found '${service_type}'."
            exit 1
          fi

          blueprints_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/blueprints?limit=100" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          blueprints_body="$(echo "$blueprints_resp" | head -n -1)"
          blueprints_status="$(echo "$blueprints_resp" | tail -n 1)"

          if [ "$blueprints_status" -ge 300 ]; then
            echo "::error::Failed to list Render blueprints (HTTP ${blueprints_status})."
            echo "$blueprints_body"
            exit 1
          fi

          blueprint_ids="$(echo "$blueprints_body" | jq -r '.[]?.blueprint?.id // .[]?.id // empty')"
          if [ -z "$blueprint_ids" ]; then
            echo "::error::No Render blueprints were found for this API key."
            exit 1
          fi

          matched_blueprint_id=""
          matched_blueprint_name=""
          matched_blueprint_path=""
          matched_auto_sync=""
          matched_last_sync=""

          for blueprint_id in $blueprint_ids; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${blueprint_id}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Could not retrieve blueprint ${blueprint_id} (HTTP ${detail_status}); skipping."
              continue
            fi

            if echo "$detail_body" | jq -e --arg sid "$service_id" --arg sn "$SERVICE_NAME" '.resources[]? | select((.id == $sid) or (.name == $sn and .type == "web_service"))' >/dev/null; then
              matched_blueprint_id="$blueprint_id"
              matched_blueprint_name="$(echo "$detail_body" | jq -r '.name // empty')"
              matched_blueprint_path="$(echo "$detail_body" | jq -r '.path // empty')"
              matched_auto_sync="$(echo "$detail_body" | jq -r '.autoSync // false')"
              matched_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              break
            fi
          done

          if [ -z "$matched_blueprint_id" ]; then
            echo "::error::No Blueprint managing '${SERVICE_NAME}' (service ID ${service_id}) was found."
            echo "::error::Option 3 requires this service to be managed by a Render Blueprint."
            exit 1
          fi

          echo "::notice::Matched Blueprint id='${matched_blueprint_id}', name='${matched_blueprint_name}', path='${matched_blueprint_path}', autoSync='${matched_auto_sync}', lastSync='${matched_last_sync}'"
          {
            echo "service_id=${service_id}"
            echo "blueprint_id=${matched_blueprint_id}"
            echo "blueprint_auto_sync=${matched_auto_sync}"
            echo "blueprint_last_sync=${matched_last_sync}"
          } >> "$GITHUB_OUTPUT"

      - name: Enable Blueprint autoSync
        if: steps.window.outputs.configured == 'true' && steps.blueprint.outputs.blueprint_auto_sync != 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
        run: |
          set -euo pipefail

          patch_resp="$(curl -sS -w "\n%{http_code}" \
            -X PATCH "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d '{"autoSync":true}')"

          patch_body="$(echo "$patch_resp" | head -n -1)"
          patch_status="$(echo "$patch_resp" | tail -n 1)"

          if [ "$patch_status" -ge 300 ]; then
            echo "::error::Failed to enable autoSync on blueprint ${BLUEPRINT_ID} (HTTP ${patch_status})."
            echo "$patch_body"
            exit 1
          fi

          echo "::notice::Enabled autoSync for blueprint ${BLUEPRINT_ID}."

      - name: Resolve Render Postgres IDs for window routing
        if: steps.window.outputs.configured == 'true'
        id: postgres
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          DEFAULT_DATABASE_NAME: ${{ steps.window.outputs.default_database_name }}
          WINDOW_DATABASE_NAME: ${{ steps.window.outputs.window_database_name }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          postgres_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/postgres?limit=100" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          postgres_body="$(echo "$postgres_resp" | head -n -1)"
          postgres_status="$(echo "$postgres_resp" | tail -n 1)"

          if [ "$postgres_status" -ge 300 ]; then
            echo "::error::Failed to list Render Postgres instances (HTTP ${postgres_status})."
            echo "$postgres_body"
            exit 1
          fi

          default_db_id="$(echo "$postgres_body" | jq -r --arg n "$DEFAULT_DATABASE_NAME" '[.[] | (.postgres // .) | select(.name == $n) | .id][0] // empty')"
          window_db_id="$(echo "$postgres_body" | jq -r --arg n "$WINDOW_DATABASE_NAME" '[.[] | (.postgres // .) | select(.name == $n) | .id][0] // empty')"

          if [ -z "$default_db_id" ]; then
            echo "::error::Default database '${DEFAULT_DATABASE_NAME}' was not found in Render account."
            exit 1
          fi

          if [ -z "$window_db_id" ]; then
            echo "::error::Window database '${WINDOW_DATABASE_NAME}' was not found in Render account."
            exit 1
          fi

          if [ "$default_db_id" = "$window_db_id" ]; then
            echo "::error::Default and window databases resolve to the same Postgres ID (${default_db_id})."
            exit 1
          fi

          echo "::notice::Resolved Postgres IDs: default=${DEFAULT_DATABASE_NAME} (${default_db_id}), window=${WINDOW_DATABASE_NAME} (${window_db_id})."
          {
            echo "default_db_id=${default_db_id}"
            echo "window_db_id=${window_db_id}"
          } >> "$GITHUB_OUTPUT"

      - name: Resume window database before switching traffic
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase == 'inside_window'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          WINDOW_DB_ID: ${{ steps.postgres.outputs.window_db_id }}
          WINDOW_DATABASE_NAME: ${{ steps.window.outputs.window_database_name }}
        run: |
          set -euo pipefail

          if [ -z "${WINDOW_DB_ID:-}" ]; then
            echo "::error::Missing window Postgres ID."
            exit 1
          fi

          detail_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/postgres/${WINDOW_DB_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          detail_body="$(echo "$detail_resp" | head -n -1)"
          detail_status="$(echo "$detail_resp" | tail -n 1)"
          if [ "$detail_status" -ge 300 ]; then
            echo "::error::Failed to fetch Postgres '${WINDOW_DATABASE_NAME}' (HTTP ${detail_status})."
            echo "$detail_body"
            exit 1
          fi

          current_suspended="$(echo "$detail_body" | jq -r '.suspended // empty')"
          echo "::notice::Current window DB suspended state: ${current_suspended}"

          if [ "$current_suspended" = "not_suspended" ]; then
            echo "::notice::Window database already resumed."
            exit 0
          fi

          resume_resp="$(curl -sS -w "\n%{http_code}" \
            -X POST "https://api.render.com/v1/postgres/${WINDOW_DB_ID}/resume" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          resume_body="$(echo "$resume_resp" | head -n -1)"
          resume_status="$(echo "$resume_resp" | tail -n 1)"
          if [ "$resume_status" -ge 300 ]; then
            echo "::error::Failed to resume Postgres '${WINDOW_DATABASE_NAME}' (HTTP ${resume_status})."
            echo "$resume_body"
            exit 1
          fi

          attempts=1
          max_attempts=60
          sleep_seconds=10
          while [ "$attempts" -le "$max_attempts" ]; do
            poll_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/postgres/${WINDOW_DB_ID}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"
            poll_body="$(echo "$poll_resp" | head -n -1)"
            poll_status="$(echo "$poll_resp" | tail -n 1)"

            if [ "$poll_status" -ge 300 ]; then
              echo "::warning::Polling Postgres resume status failed (HTTP ${poll_status}); retrying."
            else
              suspended_state="$(echo "$poll_body" | jq -r '.suspended // empty')"
              postgres_status="$(echo "$poll_body" | jq -r '.status // empty')"
              echo "Resume poll ${attempts}/${max_attempts}: suspended=${suspended_state}, status=${postgres_status}"
              if [ "$suspended_state" = "not_suspended" ]; then
                echo "::notice::Window database is resumed."
                exit 0
              fi
            fi

            attempts=$((attempts + 1))
            sleep "$sleep_seconds"
          done

          echo "::error::Timed out waiting for window database resume."
          exit 1

      - name: Reconcile render.yaml plans
        if: steps.window.outputs.configured == 'true'
        id: file-plan
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          TARGET_SERVICE_PLAN: ${{ steps.window.outputs.target_service_plan }}
          TARGET_DATABASE_NAME: ${{ steps.window.outputs.target_database_name }}
          DATABASE_URL_ENV_KEY: ${{ steps.window.outputs.database_url_env_key }}
          DATABASE_NAME_ENV_KEY: ${{ steps.window.outputs.database_name_env_key }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"
          git fetch origin "$branch"
          git checkout -B "$branch" "origin/$branch"
          git pull --ff-only origin "$branch"

          python - <<'PY'
          import os
          import re

          path = "render.yaml"
          service_name = os.environ["SERVICE_NAME"].strip()
          target_service_plan = os.environ["TARGET_SERVICE_PLAN"].strip()
          target_database_name = os.environ["TARGET_DATABASE_NAME"].strip()
          database_url_env_key = os.environ["DATABASE_URL_ENV_KEY"].strip()
          database_name_env_key = os.environ["DATABASE_NAME_ENV_KEY"].strip()

          if not service_name or not target_service_plan or not target_database_name or not database_url_env_key or not database_name_env_key:
              raise SystemExit("SERVICE_NAME, TARGET_SERVICE_PLAN, TARGET_DATABASE_NAME, DATABASE_URL_ENV_KEY, and DATABASE_NAME_ENV_KEY are required.")

          with open(path, "r", encoding="utf-8") as f:
              lines = f.readlines()

          def indent_len(s: str) -> int:
              return len(s) - len(s.lstrip(" "))

          def find_production_bounds(lines_):
              start = None
              indent = None
              env_pattern = re.compile(r'^(\s*)-\s+name:\s*("?)([^"\n]+)\2\s*$')
              for idx, line in enumerate(lines_):
                  m = env_pattern.match(line)
                  if not m:
                      continue
                  name = m.group(3).strip()
                  cur_indent = len(m.group(1))
                  if name == "Production" and cur_indent == 6:
                      start = idx
                      indent = cur_indent
                      break
              if start is None:
                  raise SystemExit(f"Production environment was not found in {path}.")

              end = len(lines_)
              for idx in range(start + 1, len(lines_)):
                  m = env_pattern.match(lines_[idx])
                  if m and len(m.group(1)) == indent:
                      end = idx
                      break
              return start, end, indent

          def find_services_bounds(lines_, prod_start, prod_end, prod_indent):
              services_indent = prod_indent + 2
              services_start = None
              for idx in range(prod_start + 1, prod_end):
                  if lines_[idx].strip() == "services:" and indent_len(lines_[idx]) == services_indent:
                      services_start = idx
                      break
              if services_start is None:
                  raise SystemExit("Production services block was not found in render.yaml.")

              services_end = prod_end
              for idx in range(services_start + 1, prod_end):
                  stripped = lines_[idx].strip()
                  if stripped and not stripped.startswith("#") and indent_len(lines_[idx]) <= services_indent:
                      services_end = idx
                      break
              return services_start, services_end, services_indent

          def find_service_item_bounds(lines_, services_start, services_end, services_indent, target_service):
              item_indent = services_indent + 2
              item_starts = []
              item_start_pattern = re.compile(r'^(\s*)-\s+\w+:\s*.*$')

              for idx in range(services_start + 1, services_end):
                  m = item_start_pattern.match(lines_[idx])
                  if m and len(m.group(1)) == item_indent:
                      item_starts.append(idx)

              if not item_starts:
                  raise SystemExit("No services were found in Production services block.")

              item_starts.append(services_end)
              name_pattern = re.compile(r'^\s*name:\s*("?)([^"\n]+)\1\s*$')

              for i in range(len(item_starts) - 1):
                  start = item_starts[i]
                  end = item_starts[i + 1]
                  for idx in range(start, end):
                      m = name_pattern.match(lines_[idx])
                      if m and m.group(2).strip() == target_service:
                          return start, end, item_indent

              raise SystemExit(f"Service '{target_service}' in Production services block was not found in {path}.")

          production_start, production_end, production_indent = find_production_bounds(lines)
          services_start, services_end, services_indent = find_services_bounds(lines, production_start, production_end, production_indent)
          service_start, service_end, service_item_indent = find_service_item_bounds(lines, services_start, services_end, services_indent, service_name)

          changed = False
          service_previous_plan = ""
          previous_database_binding = ""

          plan_pattern = re.compile(r'^(\s*plan:\s*)([^#\n]+?)(\s*(?:#.*)?)$')
          plan_idx = None
          for idx in range(service_start, service_end):
              line = lines[idx].rstrip("\n")
              m = plan_pattern.match(line)
              if m and indent_len(lines[idx]) >= service_item_indent + 2:
                  plan_idx = idx
                  service_previous_plan = m.group(2).strip().strip("'\"")
                  if service_previous_plan != target_service_plan:
                      lines[idx] = f"{m.group(1)}{target_service_plan}{m.group(3)}\n"
                      changed = True
                  break
          if plan_idx is None:
              raise SystemExit(f"Plan field for service '{service_name}' was not found.")

          field_indent = service_item_indent + 2
          env_header_idx = None
          for idx in range(service_start, service_end):
              if lines[idx].strip() == "envVars:" and indent_len(lines[idx]) == field_indent:
                  env_header_idx = idx
                  break

          if env_header_idx is None:
              insert_at = service_end
              env_block = [
                  " " * field_indent + "envVars:\n",
                  " " * (field_indent + 2) + f"- key: {database_url_env_key}\n",
                  " " * (field_indent + 4) + "fromDatabase:\n",
                  " " * (field_indent + 6) + f"name: {target_database_name}\n",
                  " " * (field_indent + 6) + "property: connectionString\n",
                  " " * (field_indent + 2) + f"- key: {database_name_env_key}\n",
                  " " * (field_indent + 4) + "fromDatabase:\n",
                  " " * (field_indent + 6) + f"name: {target_database_name}\n",
                  " " * (field_indent + 6) + "property: database\n",
              ]
              lines[insert_at:insert_at] = env_block
              changed = True
          else:
              env_indent = indent_len(lines[env_header_idx])
              env_end = service_end
              for idx in range(env_header_idx + 1, service_end):
                  stripped = lines[idx].strip()
                  if stripped and not stripped.startswith("#") and indent_len(lines[idx]) <= env_indent:
                      env_end = idx
                      break

              entry_indent = env_indent + 2
              entry_starts = []
              entry_pattern = re.compile(r'^(\s*)-\s+.*$')
              for idx in range(env_header_idx + 1, env_end):
                  m = entry_pattern.match(lines[idx])
                  if m and len(m.group(1)) == entry_indent:
                      entry_starts.append(idx)
              entry_starts.append(env_end)

              key_pattern = re.compile(r'^\s*-\s+key:\s*("?)([^"\n]+)\1\s*$')
              from_db_name_pattern = re.compile(r'^\s*name:\s*("?)([^"\n]+)\1\s*$')

              preserved_entries = []
              for i in range(len(entry_starts) - 1):
                  start = entry_starts[i]
                  end = entry_starts[i + 1]
                  entry_lines = lines[start:end]
                  first = entry_lines[0].rstrip("\n")
                  key_match = key_pattern.match(first)
                  key_name = key_match.group(2).strip() if key_match else ""

                  if key_name in (database_url_env_key, database_name_env_key):
                      if key_name == database_url_env_key:
                          for raw_line in entry_lines:
                              m = from_db_name_pattern.match(raw_line)
                              if m:
                                  previous_database_binding = m.group(2).strip()
                                  break
                      continue

                  preserved_entries.extend(entry_lines)

              new_entries = [
                  " " * entry_indent + f"- key: {database_url_env_key}\n",
                  " " * (entry_indent + 2) + "fromDatabase:\n",
                  " " * (entry_indent + 4) + f"name: {target_database_name}\n",
                  " " * (entry_indent + 4) + "property: connectionString\n",
                  " " * entry_indent + f"- key: {database_name_env_key}\n",
                  " " * (entry_indent + 2) + "fromDatabase:\n",
                  " " * (entry_indent + 4) + f"name: {target_database_name}\n",
                  " " * (entry_indent + 4) + "property: database\n",
              ]

              replacement = [lines[env_header_idx]] + preserved_entries + new_entries
              original = lines[env_header_idx:env_end]
              if replacement != original:
                  lines[env_header_idx:env_end] = replacement
                  changed = True

          if changed:
              with open(path, "w", encoding="utf-8") as f:
                  f.writelines(lines)

          output_file = os.environ["GITHUB_OUTPUT"]
          with open(output_file, "a", encoding="utf-8") as out:
              out.write(f"changed={'true' if changed else 'false'}\n")
              out.write(f"service_previous_plan={service_previous_plan}\n")
              out.write(f"service_target_plan={target_service_plan}\n")
              out.write(f"target_database_name={target_database_name}\n")
              out.write(f"database_binding_before={previous_database_binding}\n")
          PY

          echo "::notice::render.yaml reconciliation completed for service ${SERVICE_NAME} (plan '${TARGET_SERVICE_PLAN}') and database routing '${TARGET_DATABASE_NAME}' via env keys '${DATABASE_URL_ENV_KEY}' and '${DATABASE_NAME_ENV_KEY}'."

      - name: Commit and push render.yaml plan changes
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        id: push-plan
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          TARGET_SERVICE_PLAN: ${{ steps.window.outputs.target_service_plan }}
          TARGET_DATABASE_NAME: ${{ steps.window.outputs.target_database_name }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add render.yaml
          git commit -m "chore(render): set ${SERVICE_NAME} plan to ${TARGET_SERVICE_PLAN} and route DB to ${TARGET_DATABASE_NAME} for upgrade window [skip ci]"

          attempt=1
          max_attempts=3
          while [ "$attempt" -le "$max_attempts" ]; do
            if git push origin "HEAD:${branch}"; then
              break
            fi

            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "::error::Failed to push render.yaml plan change after ${max_attempts} attempts."
              exit 1
            fi

            attempt=$((attempt + 1))
            git fetch origin "$branch"
            git rebase "origin/${branch}"
          done

          commit_sha="$(git rev-parse HEAD)"
          echo "commit_sha=${commit_sha}" >> "$GITHUB_OUTPUT"
          echo "::notice::Pushed render.yaml plan update commit ${commit_sha}."

      - name: Wait for Blueprint sync after commit
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
          LAST_SYNC_BEFORE: ${{ steps.blueprint.outputs.blueprint_last_sync }}
        run: |
          set -euo pipefail

          if [ -z "${BLUEPRINT_ID:-}" ]; then
            echo "::warning::Missing blueprint ID; skipping sync wait."
            exit 0
          fi

          baseline="${LAST_SYNC_BEFORE:-}"
          max_attempts=36
          sleep_seconds=10
          attempt=1

          while [ "$attempt" -le "$max_attempts" ]; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Blueprint retrieve failed during sync wait (HTTP ${detail_status}); retrying."
            else
              current_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              echo "Sync wait ${attempt}/${max_attempts}: baseline='${baseline}', current='${current_last_sync}'"

              if [ -n "$current_last_sync" ] && [ "$current_last_sync" != "$baseline" ]; then
                echo "::notice::Detected Blueprint sync timestamp change: ${current_last_sync}"
                exit 0
              fi
            fi

            attempt=$((attempt + 1))
            sleep "$sleep_seconds"
          done

          echo "::warning::No Blueprint sync timestamp change detected within wait window."
          echo "::warning::Check Render dashboard Blueprint sync history to confirm reconciliation."

      - name: Suspend window database outside upgrade window
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase != 'inside_window'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          WINDOW_DB_ID: ${{ steps.postgres.outputs.window_db_id }}
          WINDOW_DATABASE_NAME: ${{ steps.window.outputs.window_database_name }}
        run: |
          set -euo pipefail

          if [ -z "${WINDOW_DB_ID:-}" ]; then
            echo "::error::Missing window Postgres ID."
            exit 1
          fi

          detail_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/postgres/${WINDOW_DB_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"
          detail_body="$(echo "$detail_resp" | head -n -1)"
          detail_status="$(echo "$detail_resp" | tail -n 1)"
          if [ "$detail_status" -ge 300 ]; then
            echo "::error::Failed to fetch Postgres '${WINDOW_DATABASE_NAME}' (HTTP ${detail_status})."
            echo "$detail_body"
            exit 1
          fi

          current_suspended="$(echo "$detail_body" | jq -r '.suspended // empty')"
          echo "::notice::Current window DB suspended state: ${current_suspended}"

          if [ "$current_suspended" = "suspended" ]; then
            echo "::notice::Window database already suspended."
            exit 0
          fi

          suspend_resp="$(curl -sS -w "\n%{http_code}" \
            -X POST "https://api.render.com/v1/postgres/${WINDOW_DB_ID}/suspend" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"
          suspend_body="$(echo "$suspend_resp" | head -n -1)"
          suspend_status="$(echo "$suspend_resp" | tail -n 1)"
          if [ "$suspend_status" -ge 300 ]; then
            echo "::error::Failed to suspend Postgres '${WINDOW_DATABASE_NAME}' (HTTP ${suspend_status})."
            echo "$suspend_body"
            exit 1
          fi

          attempts=1
          max_attempts=60
          sleep_seconds=10
          while [ "$attempts" -le "$max_attempts" ]; do
            poll_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/postgres/${WINDOW_DB_ID}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"
            poll_body="$(echo "$poll_resp" | head -n -1)"
            poll_status="$(echo "$poll_resp" | tail -n 1)"

            if [ "$poll_status" -ge 300 ]; then
              echo "::warning::Polling Postgres suspend status failed (HTTP ${poll_status}); retrying."
            else
              suspended_state="$(echo "$poll_body" | jq -r '.suspended // empty')"
              postgres_status="$(echo "$poll_body" | jq -r '.status // empty')"
              echo "Suspend poll ${attempts}/${max_attempts}: suspended=${suspended_state}, status=${postgres_status}"
              if [ "$suspended_state" = "suspended" ]; then
                echo "::notice::Window database is suspended."
                exit 0
              fi
            fi

            attempts=$((attempts + 1))
            sleep "$sleep_seconds"
          done

          echo "::error::Timed out waiting for window database suspend."
          exit 1

      - name: Delete completed window artifact
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase == 'after_end'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          ARTIFACT_ID: ${{ steps.window.outputs.artifact_id }}
        run: |
          set -euo pipefail

          if [ -z "${ARTIFACT_ID:-}" ]; then
            echo "::warning::Missing artifact ID; skipping cleanup."
            exit 0
          fi

          delete_status=$(curl -sS -o /tmp/window_artifact_delete.json -w "%{http_code}" \
            -X DELETE \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ARTIFACT_ID}")

          if [ "$delete_status" != "204" ]; then
            echo "::warning::Failed to delete completed window artifact (HTTP ${delete_status})."
            cat /tmp/window_artifact_delete.json
            exit 0
          fi

          echo "::notice::Deleted completed window artifact ${ARTIFACT_ID}."
