name: Reconcile Prod Instance Upgrade Window

on:
  workflow_dispatch:
  schedule:
    # GitHub's minimum cron interval is 5 minutes.
    - cron: "*/5 * * * *"

permissions:
  contents: read
  actions: write

concurrency:
  group: prod-instance-upgrade-window-reconciler
  cancel-in-progress: false

jobs:
  reconcile:
    name: Reconcile gfed-medusa-be instance plan
    runs-on: ubuntu-latest
    steps:
      - name: Load configured upgrade window
        id: window
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ARTIFACT_NAME="prod-instance-upgrade-window"
          LIST_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?name=${ARTIFACT_NAME}&per_page=100"

          list_status=$(curl -sS -o /tmp/window_artifacts.json -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$LIST_URL")

          if [ "$list_status" != "200" ]; then
            echo "::error::Unable to list window artifacts (HTTP ${list_status})."
            cat /tmp/window_artifacts.json
            exit 1
          fi

          artifact_json="$(jq -c '[.artifacts[] | select(.expired == false)] | sort_by(.created_at) | last // empty' /tmp/window_artifacts.json)"
          if [ -z "$artifact_json" ]; then
            echo "::notice::No active upgrade window artifact found (${ARTIFACT_NAME})."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          artifact_id="$(echo "$artifact_json" | jq -r '.id // empty')"
          artifact_created_at="$(echo "$artifact_json" | jq -r '.created_at // empty')"
          archive_url="$(echo "$artifact_json" | jq -r '.archive_download_url // empty')"

          if [ -z "$artifact_id" ] || [ -z "$archive_url" ]; then
            echo "::error::Artifact metadata is incomplete."
            echo "$artifact_json"
            exit 1
          fi

          download_status=$(curl -sS -L -o /tmp/window_artifact.zip -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$archive_url")

          if [ "$download_status" -ge 300 ]; then
            echo "::error::Unable to download window artifact (HTTP ${download_status})."
            exit 1
          fi

          if ! unzip -p /tmp/window_artifact.zip instance-window.json > window.json 2>/dev/null; then
            echo "::error::Window artifact does not contain instance-window.json."
            exit 1
          fi

          if ! jq -e . window.json >/dev/null 2>&1; then
            echo "::error::Window payload is not valid JSON."
            cat window.json
            exit 1
          fi

          enabled="$(jq -r '.enabled // true' window.json)"
          if [ "$enabled" != "true" ]; then
            echo "::notice::Upgrade window is disabled."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          service_name="$(jq -r '.service_name // empty' window.json)"
          from_plan="$(jq -r '.from_plan // empty' window.json)"
          to_plan="$(jq -r '.to_plan // empty' window.json)"
          start_epoch="$(jq -r '.start_epoch // empty' window.json)"
          end_epoch="$(jq -r '.end_epoch // empty' window.json)"
          start_utc="$(jq -r '.start_utc // empty' window.json)"
          end_utc="$(jq -r '.end_utc // empty' window.json)"

          if [ -z "$service_name" ] || [ -z "$from_plan" ] || [ -z "$to_plan" ] || [ -z "$start_epoch" ] || [ -z "$end_epoch" ]; then
            echo "::error::Window payload is missing required fields."
            cat window.json
            exit 1
          fi

          case "$start_epoch" in
            (*[!0-9]*|'')
              echo "::error::start_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          case "$end_epoch" in
            (*[!0-9]*|'')
              echo "::error::end_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          now_epoch="$(date -u +%s)"
          now_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

          if [ "$now_epoch" -lt "$start_epoch" ]; then
            phase="before_start"
            target_plan="$from_plan"
          elif [ "$now_epoch" -lt "$end_epoch" ]; then
            phase="inside_window"
            target_plan="$to_plan"
          else
            phase="after_end"
            target_plan="$from_plan"
          fi

          echo "::notice::Current phase: ${phase}; target plan: ${target_plan}"
          {
            echo "configured=true"
            echo "artifact_id=$artifact_id"
            echo "artifact_created_at=$artifact_created_at"
            echo "service_name=$service_name"
            echo "target_plan=$target_plan"
            echo "phase=$phase"
            echo "from_plan=$from_plan"
            echo "to_plan=$to_plan"
            echo "start_utc=$start_utc"
            echo "end_utc=$end_utc"
            echo "now_utc=$now_utc"
          } >> "$GITHUB_OUTPUT"

      - name: Reconcile Render service plan
        if: steps.window.outputs.configured == 'true'
        id: reconcile
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          TARGET_PLAN: ${{ steps.window.outputs.target_plan }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          service_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/services?name=${SERVICE_NAME}&limit=1" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          service_body="$(echo "$service_resp" | head -n -1)"
          service_status="$(echo "$service_resp" | tail -n 1)"

          if [ "$service_status" -ge 300 ]; then
            echo "::error::Failed to fetch Render service '${SERVICE_NAME}' (HTTP ${service_status})."
            echo "$service_body"
            exit 1
          fi

          service_data="$(echo "$service_body" | jq -c '.[0].service // empty')"
          if [ -z "$service_data" ]; then
            echo "::error::Render service not found: ${SERVICE_NAME}"
            exit 1
          fi

          service_id="$(echo "$service_data" | jq -r '.id // empty')"
          current_plan="$(echo "$service_data" | jq -r '.serviceDetails.plan // .plan // empty')"
          resolved_service_name="$(echo "$service_data" | jq -r '.name // empty')"
          resolved_service_slug="$(echo "$service_data" | jq -r '.slug // empty')"

          if [ -z "$service_id" ]; then
            echo "::error::Could not determine service ID for ${SERVICE_NAME}."
            exit 1
          fi

          if [ -z "$current_plan" ]; then
            echo "::error::Could not determine current plan for ${SERVICE_NAME}."
            echo "$service_data"
            exit 1
          fi

          echo "::notice::Resolved Render service: query_name='${SERVICE_NAME}', resolved_name='${resolved_service_name}', slug='${resolved_service_slug}', service_id='${service_id}', current_plan='${current_plan}'"
          if [ -n "$resolved_service_name" ] && [ "$resolved_service_name" != "$SERVICE_NAME" ]; then
            echo "::warning::Resolved service name differs from configured service name."
          fi

          echo "service_id=${service_id}" >> "$GITHUB_OUTPUT"
          echo "current_plan=${current_plan}" >> "$GITHUB_OUTPUT"
          echo "target_plan=${TARGET_PLAN}" >> "$GITHUB_OUTPUT"

          if [ "$current_plan" = "$TARGET_PLAN" ]; then
            echo "::notice::Plan already '${TARGET_PLAN}'. No change needed."
            echo "plan_changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          get_current_plan() {
            local resp body status plan
            resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/services/${service_id}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            body="$(echo "$resp" | head -n -1)"
            status="$(echo "$resp" | tail -n 1)"

            if [ "$status" -lt 300 ]; then
              plan="$(echo "$body" | jq -r '.serviceDetails.plan // .plan // .service.serviceDetails.plan // .service.plan // empty')"
              if [ -n "$plan" ]; then
                echo "$plan"
                return 0
              fi
            fi

            resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/services?name=${SERVICE_NAME}&limit=1" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            body="$(echo "$resp" | head -n -1)"
            status="$(echo "$resp" | tail -n 1)"

            if [ "$status" -ge 300 ]; then
              echo ""
              return 1
            fi

            plan="$(echo "$body" | jq -r '.[0].service.serviceDetails.plan // .[0].service.plan // empty')"
            if [ -z "$plan" ]; then
              echo ""
              return 1
            fi

            echo "$plan"
            return 0
          }

          wait_for_target_plan() {
            local max_attempts=24
            local sleep_seconds=10
            local attempt=1
            local observed=""

            while [ "$attempt" -le "$max_attempts" ]; do
              if observed="$(get_current_plan)"; then
                echo "Verification attempt ${attempt}/${max_attempts}: observed plan '${observed}'" >&2
                if [ "$observed" = "$TARGET_PLAN" ]; then
                  echo "$observed"
                  return 0
                fi
              else
                echo "Verification attempt ${attempt}/${max_attempts}: could not read current plan yet" >&2
              fi

              attempt=$((attempt + 1))
              sleep "$sleep_seconds"
            done

            echo "${observed}"
            return 1
          }

          patch_service() {
            local payload="$1"
            local label="$2"

            patch_resp="$(curl -sS -w "\n%{http_code}" \
              -X PATCH "https://api.render.com/v1/services/${service_id}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d "$payload")"

            patch_body="$(echo "$patch_resp" | head -n -1)"
            patch_status="$(echo "$patch_resp" | tail -n 1)"

            if [ "$patch_status" -ge 300 ]; then
              echo "::warning::Patch with ${label} failed (HTTP ${patch_status})."
              echo "$patch_body"
              return 1
            fi

            echo "::notice::Patch with ${label} succeeded."
            return 0
          }

          payload_service_details="$(jq -cn --arg plan "$TARGET_PLAN" '{serviceDetails:{plan:$plan}}')"
          payload_root="$(jq -cn --arg plan "$TARGET_PLAN" '{plan:$plan}')"
          patched_with=""

          if patch_service "$payload_service_details" "serviceDetails.plan"; then
            patched_with="serviceDetails.plan"
          else
            if ! patch_service "$payload_root" "plan"; then
              echo "::error::All plan update patch attempts failed."
              exit 1
            fi
            patched_with="plan"
          fi

          if ! updated_plan="$(wait_for_target_plan)"; then
            echo "::warning::Plan did not converge after first patch attempt; trying alternate payload."

            if [ "$patched_with" = "serviceDetails.plan" ]; then
              retry_payload="$payload_root"
              retry_label="plan"
            else
              retry_payload="$payload_service_details"
              retry_label="serviceDetails.plan"
            fi

            if ! patch_service "$retry_payload" "$retry_label"; then
              echo "::error::Plan verification failed. Expected '${TARGET_PLAN}', got '${updated_plan}'."
              exit 1
            fi

            if ! updated_plan="$(wait_for_target_plan)"; then
              echo "::error::Plan verification failed after retry. Expected '${TARGET_PLAN}', got '${updated_plan}'."
              exit 1
            fi
          fi

          echo "::notice::Plan changed from '${current_plan}' to '${updated_plan}'."
          echo "plan_changed=true" >> "$GITHUB_OUTPUT"

      - name: Delete completed window artifact
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase == 'after_end'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          ARTIFACT_ID: ${{ steps.window.outputs.artifact_id }}
        run: |
          set -euo pipefail

          if [ -z "${ARTIFACT_ID:-}" ]; then
            echo "::warning::Missing artifact ID; skipping cleanup."
            exit 0
          fi

          delete_status=$(curl -sS -o /tmp/window_artifact_delete.json -w "%{http_code}" \
            -X DELETE \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ARTIFACT_ID}")

          if [ "$delete_status" != "204" ]; then
            echo "::warning::Failed to delete completed window artifact (HTTP ${delete_status})."
            cat /tmp/window_artifact_delete.json
            exit 0
          fi

          echo "::notice::Deleted completed window artifact ${ARTIFACT_ID}."
