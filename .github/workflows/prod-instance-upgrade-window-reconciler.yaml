name: Reconcile Prod Instance Upgrade Window

on:
  workflow_dispatch:
  schedule:
    # GitHub's minimum cron interval is 5 minutes.
    - cron: "*/5 * * * *"

permissions:
  contents: write
  actions: write

concurrency:
  group: prod-instance-upgrade-window-reconciler
  cancel-in-progress: false

jobs:
  reconcile:
    name: Reconcile gfed-medusa-be instance plan
    runs-on: ubuntu-latest
    steps:
      - name: Load configured upgrade window
        id: window
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ARTIFACT_NAME="prod-instance-upgrade-window"
          LIST_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?name=${ARTIFACT_NAME}&per_page=100"

          list_status=$(curl -sS -o /tmp/window_artifacts.json -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$LIST_URL")

          if [ "$list_status" != "200" ]; then
            echo "::error::Unable to list window artifacts (HTTP ${list_status})."
            cat /tmp/window_artifacts.json
            exit 1
          fi

          artifact_json="$(jq -c '[.artifacts[] | select(.expired == false)] | sort_by(.created_at) | last // empty' /tmp/window_artifacts.json)"
          if [ -z "$artifact_json" ]; then
            echo "::notice::No active upgrade window artifact found (${ARTIFACT_NAME})."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          artifact_id="$(echo "$artifact_json" | jq -r '.id // empty')"
          artifact_created_at="$(echo "$artifact_json" | jq -r '.created_at // empty')"
          archive_url="$(echo "$artifact_json" | jq -r '.archive_download_url // empty')"

          if [ -z "$artifact_id" ] || [ -z "$archive_url" ]; then
            echo "::error::Artifact metadata is incomplete."
            echo "$artifact_json"
            exit 1
          fi

          download_status=$(curl -sS -L -o /tmp/window_artifact.zip -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$archive_url")

          if [ "$download_status" -ge 300 ]; then
            echo "::error::Unable to download window artifact (HTTP ${download_status})."
            exit 1
          fi

          if ! unzip -p /tmp/window_artifact.zip instance-window.json > window.json 2>/dev/null; then
            echo "::error::Window artifact does not contain instance-window.json."
            exit 1
          fi

          if ! jq -e . window.json >/dev/null 2>&1; then
            echo "::error::Window payload is not valid JSON."
            cat window.json
            exit 1
          fi

          enabled="$(jq -r '.enabled // true' window.json)"
          if [ "$enabled" != "true" ]; then
            echo "::notice::Upgrade window is disabled."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          service_name="$(jq -r '.service_name // empty' window.json)"
          from_plan="$(jq -r '.from_plan // empty' window.json)"
          to_plan="$(jq -r '.to_plan // empty' window.json)"
          start_epoch="$(jq -r '.start_epoch // empty' window.json)"
          end_epoch="$(jq -r '.end_epoch // empty' window.json)"
          start_utc="$(jq -r '.start_utc // empty' window.json)"
          end_utc="$(jq -r '.end_utc // empty' window.json)"

          if [ -z "$service_name" ] || [ -z "$from_plan" ] || [ -z "$to_plan" ] || [ -z "$start_epoch" ] || [ -z "$end_epoch" ]; then
            echo "::error::Window payload is missing required fields."
            cat window.json
            exit 1
          fi

          case "$start_epoch" in
            (*[!0-9]*|'')
              echo "::error::start_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          case "$end_epoch" in
            (*[!0-9]*|'')
              echo "::error::end_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          now_epoch="$(date -u +%s)"
          now_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

          if [ "$now_epoch" -lt "$start_epoch" ]; then
            phase="before_start"
            target_plan="$from_plan"
          elif [ "$now_epoch" -lt "$end_epoch" ]; then
            phase="inside_window"
            target_plan="$to_plan"
          else
            phase="after_end"
            target_plan="$from_plan"
          fi

          echo "::notice::Current phase: ${phase}; target plan: ${target_plan}"
          {
            echo "configured=true"
            echo "artifact_id=$artifact_id"
            echo "artifact_created_at=$artifact_created_at"
            echo "service_name=$service_name"
            echo "target_plan=$target_plan"
            echo "phase=$phase"
            echo "from_plan=$from_plan"
            echo "to_plan=$to_plan"
            echo "start_utc=$start_utc"
            echo "end_utc=$end_utc"
            echo "now_utc=$now_utc"
          } >> "$GITHUB_OUTPUT"

      - name: Checkout default branch
        if: steps.window.outputs.configured == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch || github.ref_name }}
          fetch-depth: 0

      - name: Resolve Blueprint for target service
        if: steps.window.outputs.configured == 'true'
        id: blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          service_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/services?name=${SERVICE_NAME}&limit=1" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          service_body="$(echo "$service_resp" | head -n -1)"
          service_status="$(echo "$service_resp" | tail -n 1)"

          if [ "$service_status" -ge 300 ]; then
            echo "::error::Failed to fetch Render service '${SERVICE_NAME}' (HTTP ${service_status})."
            echo "$service_body"
            exit 1
          fi

          service_id="$(echo "$service_body" | jq -r '.[0].service.id // empty')"
          service_type="$(echo "$service_body" | jq -r '.[0].service.type // empty')"

          if [ -z "$service_id" ]; then
            echo "::error::Render service not found: ${SERVICE_NAME}"
            exit 1
          fi

          if [ "$service_type" != "web_service" ]; then
            echo "::error::Expected '${SERVICE_NAME}' to be a web service, found '${service_type}'."
            exit 1
          fi

          blueprints_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/blueprints?limit=100" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          blueprints_body="$(echo "$blueprints_resp" | head -n -1)"
          blueprints_status="$(echo "$blueprints_resp" | tail -n 1)"

          if [ "$blueprints_status" -ge 300 ]; then
            echo "::error::Failed to list Render blueprints (HTTP ${blueprints_status})."
            echo "$blueprints_body"
            exit 1
          fi

          blueprint_ids="$(echo "$blueprints_body" | jq -r '.[]?.blueprint?.id // .[]?.id // empty')"
          if [ -z "$blueprint_ids" ]; then
            echo "::error::No Render blueprints were found for this API key."
            exit 1
          fi

          matched_blueprint_id=""
          matched_blueprint_name=""
          matched_blueprint_path=""
          matched_auto_sync=""
          matched_last_sync=""

          for blueprint_id in $blueprint_ids; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${blueprint_id}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Could not retrieve blueprint ${blueprint_id} (HTTP ${detail_status}); skipping."
              continue
            fi

            if echo "$detail_body" | jq -e --arg sid "$service_id" --arg sn "$SERVICE_NAME" '.resources[]? | select((.id == $sid) or (.name == $sn and .type == "web_service"))' >/dev/null; then
              matched_blueprint_id="$blueprint_id"
              matched_blueprint_name="$(echo "$detail_body" | jq -r '.name // empty')"
              matched_blueprint_path="$(echo "$detail_body" | jq -r '.path // empty')"
              matched_auto_sync="$(echo "$detail_body" | jq -r '.autoSync // false')"
              matched_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              break
            fi
          done

          if [ -z "$matched_blueprint_id" ]; then
            echo "::error::No Blueprint managing '${SERVICE_NAME}' (service ID ${service_id}) was found."
            echo "::error::Option 3 requires this service to be managed by a Render Blueprint."
            exit 1
          fi

          echo "::notice::Matched Blueprint id='${matched_blueprint_id}', name='${matched_blueprint_name}', path='${matched_blueprint_path}', autoSync='${matched_auto_sync}', lastSync='${matched_last_sync}'"
          {
            echo "service_id=${service_id}"
            echo "blueprint_id=${matched_blueprint_id}"
            echo "blueprint_auto_sync=${matched_auto_sync}"
            echo "blueprint_last_sync=${matched_last_sync}"
          } >> "$GITHUB_OUTPUT"

      - name: Enable Blueprint autoSync
        if: steps.window.outputs.configured == 'true' && steps.blueprint.outputs.blueprint_auto_sync != 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
        run: |
          set -euo pipefail

          patch_resp="$(curl -sS -w "\n%{http_code}" \
            -X PATCH "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d '{"autoSync":true}')"

          patch_body="$(echo "$patch_resp" | head -n -1)"
          patch_status="$(echo "$patch_resp" | tail -n 1)"

          if [ "$patch_status" -ge 300 ]; then
            echo "::error::Failed to enable autoSync on blueprint ${BLUEPRINT_ID} (HTTP ${patch_status})."
            echo "$patch_body"
            exit 1
          fi

          echo "::notice::Enabled autoSync for blueprint ${BLUEPRINT_ID}."

      - name: Reconcile render.yaml plan
        if: steps.window.outputs.configured == 'true'
        id: file-plan
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          TARGET_PLAN: ${{ steps.window.outputs.target_plan }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"
          git fetch origin "$branch"
          git checkout -B "$branch" "origin/$branch"
          git pull --ff-only origin "$branch"

          python - <<'PY'
          import os
          import re
          import sys

          path = "render.yaml"
          service_name = os.environ["SERVICE_NAME"].strip()
          target_plan = os.environ["TARGET_PLAN"].strip()

          if not service_name or not target_plan:
              raise SystemExit("SERVICE_NAME and TARGET_PLAN are required.")

          with open(path, "r", encoding="utf-8") as f:
              lines = f.readlines()

          in_production = False
          production_indent = None
          service_item_indent = 10
          pending_plan_idx = None
          previous_plan = ""
          changed = False
          found = False

          for i, line in enumerate(lines):
              env_match = re.match(r'^(\s*)-\s+name:\s*("?)([^"\n]+)\2\s*$', line)
              if env_match:
                  indent = len(env_match.group(1))
                  env_name = env_match.group(3).strip()
                  if indent == 6:
                      if env_name == "Production":
                          in_production = True
                          production_indent = indent
                          pending_plan_idx = None
                          continue
                      if in_production and production_indent == indent:
                          in_production = False
                          pending_plan_idx = None

              if not in_production:
                  continue

              service_start_match = re.match(r'^(\s*)-\s+\w+:\s*.*$', line)
              if service_start_match and len(service_start_match.group(1)) == service_item_indent:
                  pending_plan_idx = None

              plan_match = re.match(r'^(\s*plan:\s*)([^#\n]+)(\s*(?:#.*)?)$', line.rstrip("\n"))
              if plan_match and len(plan_match.group(1)) >= 12:
                  pending_plan_idx = i

              name_match = re.match(r'^(\s*)name:\s*("?)([^"\n]+)\2\s*$', line)
              if name_match and len(name_match.group(1)) >= 12:
                  current_name = name_match.group(3).strip()
                  if current_name != service_name:
                      continue

                  found = True
                  if pending_plan_idx is None:
                      raise SystemExit(f"Found service '{service_name}' but no corresponding plan field.")

                  original = lines[pending_plan_idx].rstrip("\n")
                  m = re.match(r'^(\s*plan:\s*)([^#\n]+?)(\s*(?:#.*)?)$', original)
                  if not m:
                      raise SystemExit("Failed to parse plan line for target service.")

                  previous_plan = m.group(2).strip().strip("'\"")
                  if previous_plan != target_plan:
                      lines[pending_plan_idx] = f"{m.group(1)}{target_plan}{m.group(3)}\n"
                      changed = True
                  break

          if not found:
              raise SystemExit(f"Service '{service_name}' in Production environment was not found in {path}.")

          if changed:
              with open(path, "w", encoding="utf-8") as f:
                  f.writelines(lines)

          output_file = os.environ["GITHUB_OUTPUT"]
          with open(output_file, "a", encoding="utf-8") as out:
              out.write(f"changed={'true' if changed else 'false'}\n")
              out.write(f"previous_plan={previous_plan}\n")
              out.write(f"target_plan={target_plan}\n")
          PY

          echo "::notice::render.yaml reconciliation completed for ${SERVICE_NAME}; target plan '${TARGET_PLAN}'."

      - name: Commit and push render.yaml plan change
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        id: push-plan
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          TARGET_PLAN: ${{ steps.window.outputs.target_plan }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add render.yaml
          git commit -m "chore(render): set ${SERVICE_NAME} plan to ${TARGET_PLAN} for upgrade window [skip ci]"

          attempt=1
          max_attempts=3
          while [ "$attempt" -le "$max_attempts" ]; do
            if git push origin "HEAD:${branch}"; then
              break
            fi

            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "::error::Failed to push render.yaml plan change after ${max_attempts} attempts."
              exit 1
            fi

            attempt=$((attempt + 1))
            git fetch origin "$branch"
            git rebase "origin/${branch}"
          done

          commit_sha="$(git rev-parse HEAD)"
          echo "commit_sha=${commit_sha}" >> "$GITHUB_OUTPUT"
          echo "::notice::Pushed render.yaml plan update commit ${commit_sha}."

      - name: Wait for Blueprint sync after commit
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
          LAST_SYNC_BEFORE: ${{ steps.blueprint.outputs.blueprint_last_sync }}
        run: |
          set -euo pipefail

          if [ -z "${BLUEPRINT_ID:-}" ]; then
            echo "::warning::Missing blueprint ID; skipping sync wait."
            exit 0
          fi

          baseline="${LAST_SYNC_BEFORE:-}"
          max_attempts=36
          sleep_seconds=10
          attempt=1

          while [ "$attempt" -le "$max_attempts" ]; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Blueprint retrieve failed during sync wait (HTTP ${detail_status}); retrying."
            else
              current_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              echo "Sync wait ${attempt}/${max_attempts}: baseline='${baseline}', current='${current_last_sync}'"

              if [ -n "$current_last_sync" ] && [ "$current_last_sync" != "$baseline" ]; then
                echo "::notice::Detected Blueprint sync timestamp change: ${current_last_sync}"
                exit 0
              fi
            fi

            attempt=$((attempt + 1))
            sleep "$sleep_seconds"
          done

          echo "::warning::No Blueprint sync timestamp change detected within wait window."
          echo "::warning::Check Render dashboard Blueprint sync history to confirm reconciliation."

      - name: Delete completed window artifact
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase == 'after_end'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          ARTIFACT_ID: ${{ steps.window.outputs.artifact_id }}
        run: |
          set -euo pipefail

          if [ -z "${ARTIFACT_ID:-}" ]; then
            echo "::warning::Missing artifact ID; skipping cleanup."
            exit 0
          fi

          delete_status=$(curl -sS -o /tmp/window_artifact_delete.json -w "%{http_code}" \
            -X DELETE \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${ARTIFACT_ID}")

          if [ "$delete_status" != "204" ]; then
            echo "::warning::Failed to delete completed window artifact (HTTP ${delete_status})."
            cat /tmp/window_artifact_delete.json
            exit 0
          fi

          echo "::notice::Deleted completed window artifact ${ARTIFACT_ID}."
