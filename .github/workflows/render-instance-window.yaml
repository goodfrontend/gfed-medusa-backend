name: Schedule Render Instance Window

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: "Render web service"
        required: true
        type: choice
        options:
          - gfed-medusa-be
          - gfed-medusa-be-qa
          - gfed-medusa-be-smoke
      target_instance_type:
        description: "Target instance type during the time window"
        required: true
        type: choice
        options:
          - free
          - starter
          - standard
      start_datetime:
        description: "Start datetime in selected timezone (format: YYYY-MM-DD HH:mm)"
        required: true
        type: string
      end_datetime:
        description: "End datetime in selected timezone (format: YYYY-MM-DD HH:mm)"
        required: true
        type: string
      timezone:
        description: "IANA timezone (example: Asia/Manila, America/New_York)"
        required: true
        type: string
        default: UTC

permissions:
  contents: read
  deployments: write
  actions: write

concurrency:
  group: render-instance-window-config
  cancel-in-progress: false

jobs:
  configure-window:
    name: Configure Render instance window
    runs-on: ubuntu-latest
    env:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      TARGET_SERVICE_NAME: ${{ inputs.service_name }}
      TARGET_INSTANCE_TYPE: ${{ inputs.target_instance_type }}
      INPUT_START: ${{ inputs.start_datetime }}
      INPUT_END: ${{ inputs.end_datetime }}
      INPUT_TIMEZONE: ${{ inputs.timezone }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure run is on default branch
        run: |
          set -euo pipefail
          if [ "$GITHUB_REF_NAME" != "$DEFAULT_BRANCH" ]; then
            echo "::error::Run this workflow on the default branch ($DEFAULT_BRANCH). Current branch: $GITHUB_REF_NAME"
            exit 1
          fi
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

      - name: Validate schedule inputs and convert to UTC
        id: schedule
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os
          import sys
          from datetime import datetime, timezone
          from zoneinfo import ZoneInfo

          start_raw = os.environ["INPUT_START"]
          end_raw = os.environ["INPUT_END"]
          timezone_raw = os.environ["INPUT_TIMEZONE"]
          output_path = os.environ["GITHUB_OUTPUT"]

          fmt = "%Y-%m-%d %H:%M"

          try:
              tz = ZoneInfo(timezone_raw)
          except Exception:
              print("::error::Invalid timezone. Use an IANA timezone such as UTC, Asia/Manila, or America/New_York.")
              sys.exit(1)

          try:
              start_local = datetime.strptime(start_raw, fmt).replace(tzinfo=tz)
              end_local = datetime.strptime(end_raw, fmt).replace(tzinfo=tz)
          except ValueError:
              print("::error::Invalid datetime format. Required format is YYYY-MM-DD HH:mm.")
              sys.exit(1)

          if end_local <= start_local:
              print("::error::end_datetime must be later than start_datetime.")
              sys.exit(1)

          start_utc = start_local.astimezone(timezone.utc)
          end_utc = end_local.astimezone(timezone.utc)

          with open(output_path, "a", encoding="utf-8") as fh:
              fh.write(f"start_epoch={int(start_utc.timestamp())}\n")
              fh.write(f"end_epoch={int(end_utc.timestamp())}\n")
              fh.write(f"start_utc={start_utc.strftime('%Y-%m-%dT%H:%M:%SZ')}\n")
              fh.write(f"end_utc={end_utc.strftime('%Y-%m-%dT%H:%M:%SZ')}\n")
          PY

      - name: Validate service against Render blueprint
        id: blueprint
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import json
          import os
          import re
          import sys

          service_name = os.environ["TARGET_SERVICE_NAME"]
          target_plan = os.environ["TARGET_INSTANCE_TYPE"]
          output_path = os.environ["GITHUB_OUTPUT"]
          allowed_plans = {"free", "starter", "standard"}

          services = {}
          in_web_service = False
          current_plan = None

          with open("render.yaml", "r", encoding="utf-8") as fh:
              for raw_line in fh:
                  line = raw_line.strip()
                  if not line:
                      continue

                  type_match = re.match(r"^- type:\s*(\S+)$", line)
                  if type_match:
                      in_web_service = type_match.group(1) == "web"
                      current_plan = None
                      continue

                  if not in_web_service:
                      continue

                  plan_match = re.match(r"^plan:\s*(\S+)$", line)
                  if plan_match:
                      current_plan = plan_match.group(1)
                      continue

                  name_match = re.match(r"^name:\s*(\S+)$", line)
                  if name_match:
                      services[name_match.group(1)] = current_plan
                      in_web_service = False
                      current_plan = None

          if service_name not in services:
              print(f"::error::Service '{service_name}' is not defined in render.yaml.")
              sys.exit(1)

          if target_plan not in allowed_plans:
              print(f"::error::target_instance_type must be one of {sorted(allowed_plans)}.")
              sys.exit(1)

          blueprint_plan = services[service_name]
          if not blueprint_plan:
              print(f"::error::Service '{service_name}' has no plan in render.yaml.")
              sys.exit(1)

          if blueprint_plan not in allowed_plans:
              print(f"::error::Service '{service_name}' in render.yaml uses unsupported plan '{blueprint_plan}'.")
              sys.exit(1)

          with open(output_path, "a", encoding="utf-8") as fh:
              fh.write(f"blueprint_plan={blueprint_plan}\n")
              fh.write(f"blueprint_services={json.dumps(sorted(services.keys()))}\n")
          PY

      - name: Resolve Render service and current instance type
        id: render
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          encoded_service_name=$(python3 - <<'PY'
          import os
          import urllib.parse
          print(urllib.parse.quote(os.environ["TARGET_SERVICE_NAME"], safe=""))
          PY
          )

          response=$(
            curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/services?name=$encoded_service_name&limit=1" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json"
          )

          body=$(echo "$response" | head -n -1)
          status=$(echo "$response" | tail -n 1)

          if [ "$status" -ge 300 ]; then
            echo "::error::Render service lookup failed ($status): $body"
            exit 1
          fi

          service_data=$(echo "$body" | jq -c '.[0].service // empty')
          service_id=$(echo "$service_data" | jq -r '.id // empty')
          current_instance_type=$(echo "$service_data" | jq -r '.serviceDetails.plan // empty')

          if [ -z "$service_id" ]; then
            echo "::error::Render service not found for '$TARGET_SERVICE_NAME'."
            exit 1
          fi

          if [ -z "$current_instance_type" ]; then
            echo "::error::Could not determine current instance type for '$TARGET_SERVICE_NAME'."
            exit 1
          fi

          case "$current_instance_type" in
            free|starter|standard) ;;
            *)
              echo "::error::Current Render instance type '$current_instance_type' is unsupported by this workflow."
              exit 1
              ;;
          esac

          {
            echo "service_id=$service_id"
            echo "current_instance_type=$current_instance_type"
          } >> "$GITHUB_OUTPUT"

      - name: Skip when current type already equals target type
        id: gate
        run: |
          set -euo pipefail

          current="${{ steps.render.outputs.current_instance_type }}"
          target="$TARGET_INSTANCE_TYPE"

          if [ "$current" = "$target" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Service '$TARGET_SERVICE_NAME' already uses '$target'. Skipping schedule creation."
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"

      - name: Persist instance window in deployment state
        if: steps.gate.outputs.skip == 'false'
        id: persist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          START_EPOCH: ${{ steps.schedule.outputs.start_epoch }}
          END_EPOCH: ${{ steps.schedule.outputs.end_epoch }}
          START_UTC: ${{ steps.schedule.outputs.start_utc }}
          END_UTC: ${{ steps.schedule.outputs.end_utc }}
          BLUEPRINT_PLAN: ${{ steps.blueprint.outputs.blueprint_plan }}
          CURRENT_INSTANCE_TYPE: ${{ steps.render.outputs.current_instance_type }}
          SERVICE_ID: ${{ steps.render.outputs.service_id }}
        run: |
          set -euo pipefail

          state_environment="render-instance-window-state"
          now_epoch=$(date -u +%s)

          window_json=$(jq -cn \
            --arg service_name "$TARGET_SERVICE_NAME" \
            --arg service_id "$SERVICE_ID" \
            --arg target_instance_type "$TARGET_INSTANCE_TYPE" \
            --arg original_instance_type "$CURRENT_INSTANCE_TYPE" \
            --arg blueprint_instance_type "$BLUEPRINT_PLAN" \
            --arg timezone "$INPUT_TIMEZONE" \
            --arg start_local "$INPUT_START" \
            --arg end_local "$INPUT_END" \
            --arg start_utc "$START_UTC" \
            --arg end_utc "$END_UTC" \
            --arg created_by "${GITHUB_ACTOR}" \
            --arg created_from_run "${GITHUB_RUN_ID}" \
            --argjson start_epoch "$START_EPOCH" \
            --argjson end_epoch "$END_EPOCH" \
            --argjson created_at_epoch "$now_epoch" \
            '{
              service_name: $service_name,
              service_id: $service_id,
              target_instance_type: $target_instance_type,
              original_instance_type: $original_instance_type,
              blueprint_instance_type: $blueprint_instance_type,
              timezone: $timezone,
              start_local: $start_local,
              end_local: $end_local,
              start_utc: $start_utc,
              end_utc: $end_utc,
              start_epoch: $start_epoch,
              end_epoch: $end_epoch,
              created_by: $created_by,
              created_from_run: $created_from_run,
              created_at_epoch: $created_at_epoch
            }'
          )

          list_response=$(
            curl -sS -w "\n%{http_code}" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments?environment=$state_environment&per_page=1" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json"
          )

          list_body=$(echo "$list_response" | head -n -1)
          list_status=$(echo "$list_response" | tail -n 1)

          if [ "$list_status" -ge 300 ]; then
            echo "::error::Unable to list deployments ($list_status): $list_body"
            exit 1
          fi

          existing_deployment_id=$(echo "$list_body" | jq -r '.[0].id // empty')
          if [ -n "$existing_deployment_id" ]; then
            inactivate_payload=$(jq -cn --arg description "Superseded by workflow run ${GITHUB_RUN_ID}" '{state: "inactive", description: $description, auto_inactive: false}')
            inactivate_response=$(
              curl -sS -w "\n%{http_code}" -X POST \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments/$existing_deployment_id/statuses" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github+json" \
                -H "Content-Type: application/json" \
                -d "$inactivate_payload"
            )

            inactivate_body=$(echo "$inactivate_response" | head -n -1)
            inactivate_status=$(echo "$inactivate_response" | tail -n 1)

            if [ "$inactivate_status" -ge 300 ]; then
              echo "::warning::Failed to inactivate previous deployment state ($inactivate_status): $inactivate_body"
            fi
          fi

          create_payload=$(jq -cn \
            --arg ref "$GITHUB_SHA" \
            --arg environment "$state_environment" \
            --arg description "Render instance window state" \
            --arg task "render-instance-window-state" \
            --argjson payload "$window_json" \
            '{
              ref: $ref,
              auto_merge: false,
              required_contexts: [],
              environment: $environment,
              description: $description,
              task: $task,
              payload: $payload
            }'
          )

          create_response=$(
            curl -sS -w "\n%{http_code}" -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$create_payload"
          )

          create_body=$(echo "$create_response" | head -n -1)
          create_status=$(echo "$create_response" | tail -n 1)

          if [ "$create_status" -ge 300 ]; then
            echo "::error::Failed to create deployment state ($create_status): $create_body"
            exit 1
          fi

          state_deployment_id=$(echo "$create_body" | jq -r '.id // empty')
          if [ -z "$state_deployment_id" ]; then
            echo "::error::Deployment state response did not include deployment id: $create_body"
            exit 1
          fi

          status_payload=$(jq -cn --arg description "Window scheduled by ${GITHUB_ACTOR}" '{state: "in_progress", description: $description, auto_inactive: false}')
          status_response=$(
            curl -sS -w "\n%{http_code}" -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments/$state_deployment_id/statuses" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$status_payload"
          )

          status_body=$(echo "$status_response" | head -n -1)
          status_code=$(echo "$status_response" | tail -n 1)

          if [ "$status_code" -ge 300 ]; then
            echo "::error::Failed to mark deployment state active ($status_code): $status_body"
            exit 1
          fi

          if [ -n "$existing_deployment_id" ]; then
            action_word="updated"
          else
            action_word="created"
          fi

          {
            echo "action_word=$action_word"
            echo "deployment_id=$state_deployment_id"
          } >> "$GITHUB_OUTPUT"

      - name: Trigger immediate reconciler run
        if: steps.gate.outputs.skip == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          dispatch_payload=$(jq -cn --arg ref "$DEFAULT_BRANCH" '{ref: $ref}')
          dispatch_response=$(
            curl -sS -w "\n%{http_code}" -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/render-instance-window-reconciler.yaml/dispatches" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$dispatch_payload"
          )

          dispatch_body=$(echo "$dispatch_response" | head -n -1)
          dispatch_status=$(echo "$dispatch_response" | tail -n 1)

          if [ "$dispatch_status" -ge 300 ]; then
            echo "::warning::Failed to trigger immediate reconciler run ($dispatch_status): $dispatch_body"
            echo "::warning::Scheduled cron reconciler will still run every 5 minutes."
          fi

      - name: Print summary
        if: always()
        env:
          SKIP: ${{ steps.gate.outputs.skip }}
          CURRENT_INSTANCE_TYPE: ${{ steps.render.outputs.current_instance_type }}
          TARGET_INSTANCE_TYPE: ${{ inputs.target_instance_type }}
          START_UTC: ${{ steps.schedule.outputs.start_utc }}
          END_UTC: ${{ steps.schedule.outputs.end_utc }}
          BLUEPRINT_PLAN: ${{ steps.blueprint.outputs.blueprint_plan }}
          STATE_ACTION: ${{ steps.persist.outputs.action_word }}
          STATE_DEPLOYMENT_ID: ${{ steps.persist.outputs.deployment_id }}
        run: |
          echo "Service: $TARGET_SERVICE_NAME"
          echo "Current instance type: $CURRENT_INSTANCE_TYPE"
          echo "Target instance type: $TARGET_INSTANCE_TYPE"
          echo "Blueprint plan in render.yaml: $BLUEPRINT_PLAN"

          if [ "$SKIP" = "true" ]; then
            echo "Skipped: service already uses target instance type."
            exit 0
          fi

          echo "State deployment #$STATE_DEPLOYMENT_ID $STATE_ACTION."
          echo "Scheduled UTC window: $START_UTC -> $END_UTC"
          echo "Reconciler will update render.yaml and patch Render directly to '$TARGET_INSTANCE_TYPE' during the window."
          echo "After end time, reconciler will revert both render.yaml and Render service back to '$CURRENT_INSTANCE_TYPE'."
          echo "Reconciler runs every 5 minutes, and this workflow also triggers an immediate reconciler run."
