name: Reconcile Render Instance Window

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

permissions:
  contents: write
  deployments: write

concurrency:
  group: render-instance-window-reconciler
  cancel-in-progress: false

jobs:
  reconcile:
    name: Reconcile Render instance type
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ github.token }}
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Load stored instance window
        id: window
        run: |
          set -euo pipefail

          state_environment="render-instance-window-state"
          list_response=$(
            curl -sS -w "\n%{http_code}" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments?environment=$state_environment&per_page=20" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json"
          )

          list_body=$(echo "$list_response" | head -n -1)
          list_status=$(echo "$list_response" | tail -n 1)

          if [ "$list_status" -ge 300 ]; then
            echo "::error::Unable to list deployments ($list_status): $list_body"
            exit 1
          fi

          deployments=$(echo "$list_body" | jq -c '[.[] | select(.task == "render-instance-window-state")]')
          deployments_count=$(echo "$deployments" | jq 'length')
          if [ "$deployments_count" -eq 0 ]; then
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "No active instance window found."
            exit 0
          fi

          active_deployment=""
          active_deployment_id=""
          while IFS= read -r deployment; do
            deployment_id=$(echo "$deployment" | jq -r '.id // empty')
            [ -z "$deployment_id" ] && continue

            status_response=$(
              curl -sS -w "\n%{http_code}" \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments/$deployment_id/statuses?per_page=1" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "Accept: application/vnd.github+json"
            )

            status_body=$(echo "$status_response" | head -n -1)
            status_code=$(echo "$status_response" | tail -n 1)

            if [ "$status_code" -ge 300 ]; then
              echo "::error::Unable to read deployment status for id $deployment_id ($status_code): $status_body"
              exit 1
            fi

            latest_state=$(echo "$status_body" | jq -r '.[0].state // "unknown"')
            if [ "$latest_state" != "inactive" ]; then
              active_deployment="$deployment"
              active_deployment_id="$deployment_id"
              break
            fi
          done < <(echo "$deployments" | jq -c '.[]')

          if [ -z "$active_deployment_id" ]; then
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "No active instance window found."
            exit 0
          fi

          window_json=$(echo "$active_deployment" | jq -c '.payload // empty')
          if [ -z "$window_json" ] || [ "$window_json" = "null" ]; then
            echo "::error::Active deployment state has empty payload."
            exit 1
          fi

          window_json=$(echo "$window_json" | jq -c 'if type=="string" then (try fromjson catch empty) else . end')
          if [ -z "$window_json" ] || [ "$window_json" = "null" ]; then
            echo "::error::Could not parse deployment payload as JSON state."
            exit 1
          fi

          echo "$window_json" | jq -e . >/dev/null

          service_name=$(echo "$window_json" | jq -r '.service_name // empty')
          service_id=$(echo "$window_json" | jq -r '.service_id // empty')
          target_instance_type=$(echo "$window_json" | jq -r '.target_instance_type // empty')
          original_instance_type=$(echo "$window_json" | jq -r '.original_instance_type // empty')
          start_epoch=$(echo "$window_json" | jq -r '.start_epoch // empty')
          end_epoch=$(echo "$window_json" | jq -r '.end_epoch // empty')
          timezone=$(echo "$window_json" | jq -r '.timezone // empty')

          if [ -z "$service_name" ] || [ -z "$target_instance_type" ] || [ -z "$original_instance_type" ] || [ -z "$start_epoch" ] || [ -z "$end_epoch" ]; then
            echo "::error::Stored window payload is missing required fields: $window_json"
            exit 1
          fi

          if [ "$start_epoch" -gt "$end_epoch" ]; then
            echo "::error::Stored window has invalid epoch range: $start_epoch > $end_epoch"
            exit 1
          fi

          now_epoch=$(date -u +%s)
          clear_window=false

          if [ "$now_epoch" -lt "$start_epoch" ]; then
            phase="before"
            desired_instance_type=""
          elif [ "$now_epoch" -le "$end_epoch" ]; then
            phase="during"
            desired_instance_type="$target_instance_type"
          else
            phase="after"
            desired_instance_type="$original_instance_type"
            clear_window=true
          fi

          {
            echo "exists=true"
            echo "state_deployment_id=$active_deployment_id"
            echo "service_name=$service_name"
            echo "service_id=$service_id"
            echo "target_instance_type=$target_instance_type"
            echo "original_instance_type=$original_instance_type"
            echo "desired_instance_type=$desired_instance_type"
            echo "start_epoch=$start_epoch"
            echo "end_epoch=$end_epoch"
            echo "timezone=$timezone"
            echo "phase=$phase"
            echo "clear_window=$clear_window"
          } >> "$GITHUB_OUTPUT"

      - name: Ensure run is on default branch
        if: steps.window.outputs.exists == 'true'
        run: |
          set -euo pipefail
          if [ "$GITHUB_REF_NAME" != "$DEFAULT_BRANCH" ]; then
            echo "::error::Run this workflow on the default branch ($DEFAULT_BRANCH). Current branch: $GITHUB_REF_NAME"
            exit 1
          fi
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}

      - name: Validate service is still defined in render.yaml
        if: steps.window.outputs.exists == 'true'
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import re
          import sys

          service_name = os.environ["SERVICE_NAME"]
          found = False

          with open("render.yaml", "r", encoding="utf-8") as fh:
              for raw_line in fh:
                  line = raw_line.strip()
                  match = re.match(r"^name:\s*(\S+)$", line)
                  if match and match.group(1) == service_name:
                      found = True
                      break

          if not found:
              print(f"::error::Service '{service_name}' is no longer present in render.yaml.")
              sys.exit(1)
          PY
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}

      - name: Read current instance type from render.yaml
        id: blueprint_current
        if: steps.window.outputs.exists == 'true'
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os
          import re
          import sys

          service_name = os.environ["SERVICE_NAME"]
          output_path = os.environ["GITHUB_OUTPUT"]

          services = {}
          in_web_service = False
          current_plan = None

          with open("render.yaml", "r", encoding="utf-8") as fh:
              for raw_line in fh:
                  line = raw_line.strip()
                  if not line:
                      continue

                  type_match = re.match(r"^- type:\s*(\S+)$", line)
                  if type_match:
                      in_web_service = type_match.group(1) == "web"
                      current_plan = None
                      continue

                  if not in_web_service:
                      continue

                  plan_match = re.match(r"^plan:\s*(\S+)$", line)
                  if plan_match:
                      current_plan = plan_match.group(1)
                      continue

                  name_match = re.match(r"^name:\s*(\S+)$", line)
                  if name_match:
                      services[name_match.group(1)] = current_plan
                      in_web_service = False
                      current_plan = None

          current = services.get(service_name)
          if not current:
              print(f"::error::Could not find current plan in render.yaml for service '{service_name}'.")
              sys.exit(1)

          with open(output_path, "a", encoding="utf-8") as fh:
              fh.write(f"current_instance_type={current}\n")
          PY
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}

      - name: Skip action before start window
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase == 'before'
        run: |
          echo "Current time is before the configured start time. No render.yaml change will be applied yet."

      - name: Fetch current Render instance type
        id: render_current
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase != 'before'
        env:
          SERVICE_ID_FROM_STATE: ${{ steps.window.outputs.service_id }}
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          service_id="$SERVICE_ID_FROM_STATE"
          current_instance_type=""

          if [ -n "$service_id" ]; then
            response=$(
              curl -sS -w "\n%{http_code}" \
                "https://api.render.com/v1/services/$service_id" \
                -H "Authorization: Bearer $RENDER_API_KEY" \
                -H "Accept: application/json"
            )

            body=$(echo "$response" | head -n -1)
            status=$(echo "$response" | tail -n 1)

            if [ "$status" -ge 300 ]; then
              echo "::warning::Direct service lookup by id failed ($status), falling back to service name."
              service_id=""
            else
              current_instance_type=$(echo "$body" | jq -r '.service.serviceDetails.plan // .serviceDetails.plan // empty')
            fi
          fi

          if [ -z "$service_id" ]; then
            encoded_service_name=$(python3 -c 'import os,urllib.parse; print(urllib.parse.quote(os.environ["SERVICE_NAME"], safe=""))')

            list_response=$(
              curl -sS -w "\n%{http_code}" \
                "https://api.render.com/v1/services?name=$encoded_service_name&limit=1" \
                -H "Authorization: Bearer $RENDER_API_KEY" \
                -H "Accept: application/json"
            )

            list_body=$(echo "$list_response" | head -n -1)
            list_status=$(echo "$list_response" | tail -n 1)

            if [ "$list_status" -ge 300 ]; then
              echo "::error::Render service lookup failed ($list_status): $list_body"
              exit 1
            fi

            service_data=$(echo "$list_body" | jq -c '.[0].service // empty')
            service_id=$(echo "$service_data" | jq -r '.id // empty')
            current_instance_type=$(echo "$service_data" | jq -r '.serviceDetails.plan // empty')
          fi

          if [ -z "$service_id" ]; then
            echo "::error::Could not resolve Render service id for '$SERVICE_NAME'."
            exit 1
          fi

          if [ -z "$current_instance_type" ]; then
            echo "::error::Could not determine current Render instance type for '$SERVICE_NAME'."
            exit 1
          fi

          case "$current_instance_type" in
            free|starter|standard) ;;
            *)
              echo "::error::Unsupported current Render instance type '$current_instance_type'."
              exit 1
              ;;
          esac

          {
            echo "service_id=$service_id"
            echo "current_instance_type=$current_instance_type"
          } >> "$GITHUB_OUTPUT"

      - name: Skip direct Render update when current already equals desired
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase != 'before' && steps.render_current.outputs.current_instance_type == steps.window.outputs.desired_instance_type
        run: |
          echo "Render service already matches desired instance type. Skipping direct Render API patch."

      - name: Update Render instance type directly
        id: render_update
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase != 'before' && steps.render_current.outputs.current_instance_type != steps.window.outputs.desired_instance_type
        env:
          SERVICE_ID: ${{ steps.render_current.outputs.service_id }}
          DESIRED_INSTANCE_TYPE: ${{ steps.window.outputs.desired_instance_type }}
        run: |
          set -euo pipefail

          payload=$(jq -cn --arg plan "$DESIRED_INSTANCE_TYPE" '{serviceDetails: {plan: $plan}}')
          response=$(
            curl -sS -w "\n%{http_code}" -X PATCH \
              "https://api.render.com/v1/services/$SERVICE_ID" \
              -H "Authorization: Bearer $RENDER_API_KEY" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d "$payload"
          )

          body=$(echo "$response" | head -n -1)
          status=$(echo "$response" | tail -n 1)

          if [ "$status" -ge 300 ]; then
            echo "::error::Failed to update Render instance type directly ($status): $body"
            exit 1
          fi

          updated_instance_type=$(echo "$body" | jq -r '.service.serviceDetails.plan // .serviceDetails.plan // empty')
          if [ "$updated_instance_type" != "$DESIRED_INSTANCE_TYPE" ]; then
            echo "::error::Render instance type update did not apply. Expected '$DESIRED_INSTANCE_TYPE', got '$updated_instance_type'."
            exit 1
          fi

          {
            echo "changed=true"
            echo "updated_instance_type=$updated_instance_type"
          } >> "$GITHUB_OUTPUT"

      - name: Skip update when render.yaml already equals desired
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase != 'before' && steps.blueprint_current.outputs.current_instance_type == steps.window.outputs.desired_instance_type
        run: |
          echo "render.yaml already matches desired instance type for this phase. Skipping commit."

      - name: Update render.yaml instance type
        id: update
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.phase != 'before' && steps.blueprint_current.outputs.current_instance_type != steps.window.outputs.desired_instance_type
        env:
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          DESIRED_INSTANCE_TYPE: ${{ steps.window.outputs.desired_instance_type }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os
          import re
          import sys

          service_name = os.environ["SERVICE_NAME"]
          desired = os.environ["DESIRED_INSTANCE_TYPE"]
          path = "render.yaml"

          with open(path, "r", encoding="utf-8") as fh:
              lines = fh.readlines()

          service_name_idx = None
          for idx, line in enumerate(lines):
              if re.match(rf"^\s*name:\s*{re.escape(service_name)}\s*$", line.strip()):
                  service_name_idx = idx
                  break

          if service_name_idx is None:
              print(f"::error::Service '{service_name}' not found in render.yaml.")
              sys.exit(1)

          block_start = None
          for idx in range(service_name_idx - 1, -1, -1):
              if re.match(r"^\s*-\s*type:\s*\S+\s*$", lines[idx].strip()):
                  block_start = idx
                  break

          if block_start is None:
              print(f"::error::Could not determine service block for '{service_name}' in render.yaml.")
              sys.exit(1)

          block_indent = len(lines[block_start]) - len(lines[block_start].lstrip(" "))
          block_end = len(lines)
          for idx in range(block_start + 1, len(lines)):
              stripped = lines[idx].lstrip(" ")
              indent = len(lines[idx]) - len(stripped)
              if indent == block_indent and re.match(r"^-\s*type:\s*\S+\s*$", stripped.strip()):
                  block_end = idx
                  break

          plan_idx = None
          for idx in range(block_start + 1, block_end):
              if re.match(r"^\s*plan:\s*\S+\s*$", lines[idx].strip()):
                  plan_idx = idx
                  break

          if plan_idx is None:
              print(f"::error::Could not find 'plan' field for service '{service_name}' in render.yaml.")
              sys.exit(1)

          original_line = lines[plan_idx]
          lines[plan_idx] = re.sub(
              r"^(\s*plan:\s*)\S+(\s*)$",
              rf"\1{desired}\2",
              original_line.rstrip("\n"),
          ) + "\n"

          with open(path, "w", encoding="utf-8") as fh:
              fh.writelines(lines)
          PY

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add render.yaml
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "updated_instance_type=${{ steps.blueprint_current.outputs.current_instance_type }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          phase="${{ steps.window.outputs.phase }}"
          git commit -m "chore(render): set ${SERVICE_NAME} plan to ${DESIRED_INSTANCE_TYPE} (${phase} window)"
          git pull --rebase origin "$GITHUB_REF_NAME"
          git push origin "HEAD:$GITHUB_REF_NAME"

          echo "changed=true" >> "$GITHUB_OUTPUT"
          echo "updated_instance_type=$DESIRED_INSTANCE_TYPE" >> "$GITHUB_OUTPUT"

      - name: Clear stored window after end time
        if: steps.window.outputs.exists == 'true' && steps.window.outputs.clear_window == 'true'
        env:
          STATE_DEPLOYMENT_ID: ${{ steps.window.outputs.state_deployment_id }}
        run: |
          set -euo pipefail

          if [ -z "$STATE_DEPLOYMENT_ID" ]; then
            echo "State deployment already cleared."
            exit 0
          fi

          payload=$(jq -cn --arg description "Window finished by run ${GITHUB_RUN_ID}" '{state: "inactive", description: $description, auto_inactive: false}')
          close_response=$(
            curl -sS -w "\n%{http_code}" -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/deployments/$STATE_DEPLOYMENT_ID/statuses" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "Content-Type: application/json" \
              -d "$payload"
          )

          close_body=$(echo "$close_response" | head -n -1)
          close_status=$(echo "$close_response" | tail -n 1)

          if [ "$close_status" -ge 300 ]; then
            echo "::error::Failed to inactivate state deployment ($close_status): $close_body"
            exit 1
          fi

          echo "Window finished. Original instance type restored in render.yaml and state deployment inactivated."

      - name: Print reconciliation summary
        if: always()
        env:
          EXISTS: ${{ steps.window.outputs.exists }}
          SERVICE_NAME: ${{ steps.window.outputs.service_name }}
          PHASE: ${{ steps.window.outputs.phase }}
          START_EPOCH: ${{ steps.window.outputs.start_epoch }}
          END_EPOCH: ${{ steps.window.outputs.end_epoch }}
          TIMEZONE: ${{ steps.window.outputs.timezone }}
          DESIRED_INSTANCE_TYPE: ${{ steps.window.outputs.desired_instance_type }}
          CURRENT_INSTANCE_TYPE: ${{ steps.blueprint_current.outputs.current_instance_type }}
          CHANGED: ${{ steps.update.outputs.changed }}
          UPDATED_INSTANCE_TYPE: ${{ steps.update.outputs.updated_instance_type }}
          RENDER_CURRENT_INSTANCE_TYPE: ${{ steps.render_current.outputs.current_instance_type }}
          RENDER_CHANGED: ${{ steps.render_update.outputs.changed }}
          RENDER_UPDATED_INSTANCE_TYPE: ${{ steps.render_update.outputs.updated_instance_type }}
        run: |
          if [ "$EXISTS" != "true" ]; then
            echo "No active instance window."
            exit 0
          fi

          echo "Service: $SERVICE_NAME"
          echo "Phase: $PHASE"
          echo "Window epoch range: $START_EPOCH -> $END_EPOCH ($TIMEZONE)"
          echo "Current render.yaml instance type before update check: $CURRENT_INSTANCE_TYPE"
          echo "Current Render instance type before update check: $RENDER_CURRENT_INSTANCE_TYPE"
          echo "Desired instance type: $DESIRED_INSTANCE_TYPE"

          if [ "$CHANGED" = "true" ]; then
            echo "Updated render.yaml instance type to: $UPDATED_INSTANCE_TYPE"
          else
            echo "No render.yaml update needed."
          fi

          if [ "$RENDER_CHANGED" = "true" ]; then
            echo "Updated Render service instance type directly to: $RENDER_UPDATED_INSTANCE_TYPE"
          else
            echo "No direct Render API update needed."
          fi
